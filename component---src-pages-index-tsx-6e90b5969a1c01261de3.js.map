{"version":3,"file":"component---src-pages-index-tsx-6e90b5969a1c01261de3.js","mappings":"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","sources":["webpack://hi-buffalo-tools/./node_modules/csv-parse/dist/esm/sync.js","webpack://hi-buffalo-tools/./node_modules/csv-stringify/dist/esm/sync.js","webpack://hi-buffalo-tools/./src/components/get-addresses-for-paper-mail/getPaperMailCustomerList.ts","webpack://hi-buffalo-tools/./src/components/get-addresses-for-paper-mail/index.tsx","webpack://hi-buffalo-tools/./src/pages/index.tsx"],"sourcesContent":["var global$1 = (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n  ? global$1.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nkMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if (Array.isArray(message)) message = message.join(\" \").trim();\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = isBuffer(value)\n          ? value.toString(options.encoding)\n          : value == null\n            ? value\n            : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nconst is_object = function (obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\n\nconst normalize_columns_array = function (columns) {\n  const normalizedColumns = [];\n  for (let i = 0, l = columns.length; i < l; i++) {\n    const column = columns[i];\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = { disabled: true };\n    } else if (typeof column === \"string\") {\n      normalizedColumns[i] = { name: column };\n    } else if (is_object(column)) {\n      if (typeof column.name !== \"string\") {\n        throw new CsvError(\"CSV_OPTION_COLUMNS_MISSING_NAME\", [\n          \"Option columns missing name:\",\n          `property \"name\" is required at position ${i}`,\n          \"when column is an object literal\",\n        ]);\n      }\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError(\"CSV_INVALID_COLUMN_DEFINITION\", [\n        \"Invalid column definition:\",\n        \"expect a string or a literal object,\",\n        `got ${JSON.stringify(column)} at position ${i}`,\n      ]);\n    }\n  }\n  return normalizedColumns;\n};\n\nclass ResizeableBuffer {\n  constructor(size = 100) {\n    this.size = size;\n    this.length = 0;\n    this.buf = Buffer.allocUnsafe(size);\n  }\n  prepend(val) {\n    if (isBuffer(val)) {\n      const length = this.length + val.length;\n      if (length >= this.size) {\n        this.resize();\n        if (length >= this.size) {\n          throw Error(\"INVALID_BUFFER_STATE\");\n        }\n      }\n      const buf = this.buf;\n      this.buf = Buffer.allocUnsafe(this.size);\n      val.copy(this.buf, 0);\n      buf.copy(this.buf, val.length);\n      this.length += val.length;\n    } else {\n      const length = this.length++;\n      if (length === this.size) {\n        this.resize();\n      }\n      const buf = this.clone();\n      this.buf[0] = val;\n      buf.copy(this.buf, 1, 0, length);\n    }\n  }\n  append(val) {\n    const length = this.length++;\n    if (length === this.size) {\n      this.resize();\n    }\n    this.buf[length] = val;\n  }\n  clone() {\n    return Buffer.from(this.buf.slice(0, this.length));\n  }\n  resize() {\n    const length = this.length;\n    this.size = this.size * 2;\n    const buf = Buffer.allocUnsafe(this.size);\n    this.buf.copy(buf, 0, 0, length);\n    this.buf = buf;\n  }\n  toString(encoding) {\n    if (encoding) {\n      return this.buf.slice(0, this.length).toString(encoding);\n    } else {\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n    }\n  }\n  toJSON() {\n    return this.toString(\"utf8\");\n  }\n  reset() {\n    this.length = 0;\n  }\n}\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst np = 12;\nconst cr$1 = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl$1 = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\nconst space = 32;\nconst tab = 9;\n\nconst init_state = function (options) {\n  return {\n    bomSkipped: false,\n    bufBytesStart: 0,\n    castField: options.cast_function,\n    commenting: false,\n    // Current error encountered by a record\n    error: undefined,\n    enabled: options.from_line === 1,\n    escaping: false,\n    escapeIsQuote:\n      isBuffer(options.escape) &&\n      isBuffer(options.quote) &&\n      Buffer.compare(options.escape, options.quote) === 0,\n    // columns can be `false`, `true`, `Array`\n    expectedRecordLength: Array.isArray(options.columns)\n      ? options.columns.length\n      : undefined,\n    field: new ResizeableBuffer(20),\n    firstLineToHeaders: options.cast_first_line_to_header,\n    needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map((delimiter) => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0,\n    ),\n    previousBuf: undefined,\n    quoting: false,\n    stop: false,\n    rawBuffer: new ResizeableBuffer(100),\n    record: [],\n    recordHasError: false,\n    record_length: 0,\n    recordDelimiterMaxLength:\n      options.record_delimiter.length === 0\n        ? 0\n        : Math.max(...options.record_delimiter.map((v) => v.length)),\n    trimChars: [\n      Buffer.from(\" \", options.encoding)[0],\n      Buffer.from(\"\\t\", options.encoding)[0],\n    ],\n    wasQuoting: false,\n    wasRowDelimiter: false,\n    timchars: [\n      Buffer.from(Buffer.from([cr$1], \"utf8\").toString(), options.encoding),\n      Buffer.from(Buffer.from([nl$1], \"utf8\").toString(), options.encoding),\n      Buffer.from(Buffer.from([np], \"utf8\").toString(), options.encoding),\n      Buffer.from(Buffer.from([space], \"utf8\").toString(), options.encoding),\n      Buffer.from(Buffer.from([tab], \"utf8\").toString(), options.encoding),\n    ],\n  };\n};\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return \"_\" + match.toLowerCase();\n  });\n};\n\nconst normalize_options = function (opts) {\n  const options = {};\n  // Merge with user options\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if (options.encoding === undefined || options.encoding === true) {\n    options.encoding = \"utf8\";\n  } else if (options.encoding === null || options.encoding === false) {\n    options.encoding = null;\n  } else if (\n    typeof options.encoding !== \"string\" &&\n    options.encoding !== null\n  ) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_ENCODING\",\n      [\n        \"Invalid option encoding:\",\n        \"encoding must be a string or null to return a buffer,\",\n        `got ${JSON.stringify(options.encoding)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `bom`\n  if (\n    options.bom === undefined ||\n    options.bom === null ||\n    options.bom === false\n  ) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_BOM\",\n      [\n        \"Invalid option bom:\",\n        \"bom must be true,\",\n        `got ${JSON.stringify(options.bom)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if (\n    options.cast === undefined ||\n    options.cast === null ||\n    options.cast === false ||\n    options.cast === \"\"\n  ) {\n    options.cast = undefined;\n  } else if (typeof options.cast === \"function\") {\n    options.cast_function = options.cast;\n    options.cast = true;\n  } else if (options.cast !== true) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_CAST\",\n      [\n        \"Invalid option cast:\",\n        \"cast must be true or a function,\",\n        `got ${JSON.stringify(options.cast)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `cast_date`\n  if (\n    options.cast_date === undefined ||\n    options.cast_date === null ||\n    options.cast_date === false ||\n    options.cast_date === \"\"\n  ) {\n    options.cast_date = false;\n  } else if (options.cast_date === true) {\n    options.cast_date = function (value) {\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  } else if (typeof options.cast_date !== \"function\") {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_CAST_DATE\",\n      [\n        \"Invalid option cast_date:\",\n        \"cast_date must be true or a function,\",\n        `got ${JSON.stringify(options.cast_date)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if (options.columns === true) {\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  } else if (typeof options.columns === \"function\") {\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  } else if (Array.isArray(options.columns)) {\n    options.columns = normalize_columns_array(options.columns);\n  } else if (\n    options.columns === undefined ||\n    options.columns === null ||\n    options.columns === false\n  ) {\n    options.columns = false;\n  } else {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_COLUMNS\",\n      [\n        \"Invalid option columns:\",\n        \"expect an array, a function or true,\",\n        `got ${JSON.stringify(options.columns)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `group_columns_by_name`\n  if (\n    options.group_columns_by_name === undefined ||\n    options.group_columns_by_name === null ||\n    options.group_columns_by_name === false\n  ) {\n    options.group_columns_by_name = false;\n  } else if (options.group_columns_by_name !== true) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME\",\n      [\n        \"Invalid option group_columns_by_name:\",\n        \"expect an boolean,\",\n        `got ${JSON.stringify(options.group_columns_by_name)}`,\n      ],\n      options,\n    );\n  } else if (options.columns === false) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME\",\n      [\n        \"Invalid option group_columns_by_name:\",\n        \"the `columns` mode must be activated.\",\n      ],\n      options,\n    );\n  }\n  // Normalize option `comment`\n  if (\n    options.comment === undefined ||\n    options.comment === null ||\n    options.comment === false ||\n    options.comment === \"\"\n  ) {\n    options.comment = null;\n  } else {\n    if (typeof options.comment === \"string\") {\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if (!isBuffer(options.comment)) {\n      throw new CsvError(\n        \"CSV_INVALID_OPTION_COMMENT\",\n        [\n          \"Invalid option comment:\",\n          \"comment must be a buffer or a string,\",\n          `got ${JSON.stringify(options.comment)}`,\n        ],\n        options,\n      );\n    }\n  }\n  // Normalize option `comment_no_infix`\n  if (\n    options.comment_no_infix === undefined ||\n    options.comment_no_infix === null ||\n    options.comment_no_infix === false\n  ) {\n    options.comment_no_infix = false;\n  } else if (options.comment_no_infix !== true) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_COMMENT\",\n      [\n        \"Invalid option comment_no_infix:\",\n        \"value must be a boolean,\",\n        `got ${JSON.stringify(options.comment_no_infix)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if (!Array.isArray(options.delimiter))\n    options.delimiter = [options.delimiter];\n  if (options.delimiter.length === 0) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_DELIMITER\",\n      [\n        \"Invalid option delimiter:\",\n        \"delimiter must be a non empty string or buffer or array of string|buffer,\",\n        `got ${delimiter_json}`,\n      ],\n      options,\n    );\n  }\n  options.delimiter = options.delimiter.map(function (delimiter) {\n    if (delimiter === undefined || delimiter === null || delimiter === false) {\n      return Buffer.from(\",\", options.encoding);\n    }\n    if (typeof delimiter === \"string\") {\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if (!isBuffer(delimiter) || delimiter.length === 0) {\n      throw new CsvError(\n        \"CSV_INVALID_OPTION_DELIMITER\",\n        [\n          \"Invalid option delimiter:\",\n          \"delimiter must be a non empty string or buffer or array of string|buffer,\",\n          `got ${delimiter_json}`,\n        ],\n        options,\n      );\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if (options.escape === undefined || options.escape === true) {\n    options.escape = Buffer.from('\"', options.encoding);\n  } else if (typeof options.escape === \"string\") {\n    options.escape = Buffer.from(options.escape, options.encoding);\n  } else if (options.escape === null || options.escape === false) {\n    options.escape = null;\n  }\n  if (options.escape !== null) {\n    if (!isBuffer(options.escape)) {\n      throw new Error(\n        `Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`,\n      );\n    }\n  }\n  // Normalize option `from`\n  if (options.from === undefined || options.from === null) {\n    options.from = 1;\n  } else {\n    if (typeof options.from === \"string\" && /\\d+/.test(options.from)) {\n      options.from = parseInt(options.from);\n    }\n    if (Number.isInteger(options.from)) {\n      if (options.from < 0) {\n        throw new Error(\n          `Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`,\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`,\n      );\n    }\n  }\n  // Normalize option `from_line`\n  if (options.from_line === undefined || options.from_line === null) {\n    options.from_line = 1;\n  } else {\n    if (\n      typeof options.from_line === \"string\" &&\n      /\\d+/.test(options.from_line)\n    ) {\n      options.from_line = parseInt(options.from_line);\n    }\n    if (Number.isInteger(options.from_line)) {\n      if (options.from_line <= 0) {\n        throw new Error(\n          `Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`,\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`,\n      );\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if (\n    options.ignore_last_delimiters === undefined ||\n    options.ignore_last_delimiters === null\n  ) {\n    options.ignore_last_delimiters = false;\n  } else if (typeof options.ignore_last_delimiters === \"number\") {\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if (options.ignore_last_delimiters === 0) {\n      options.ignore_last_delimiters = false;\n    }\n  } else if (typeof options.ignore_last_delimiters !== \"boolean\") {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS\",\n      [\n        \"Invalid option `ignore_last_delimiters`:\",\n        \"the value must be a boolean value or an integer,\",\n        `got ${JSON.stringify(options.ignore_last_delimiters)}`,\n      ],\n      options,\n    );\n  }\n  if (options.ignore_last_delimiters === true && options.columns === false) {\n    throw new CsvError(\n      \"CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS\",\n      [\n        \"The option `ignore_last_delimiters`\",\n        \"requires the activation of the `columns` option\",\n      ],\n      options,\n    );\n  }\n  // Normalize option `info`\n  if (\n    options.info === undefined ||\n    options.info === null ||\n    options.info === false\n  ) {\n    options.info = false;\n  } else if (options.info !== true) {\n    throw new Error(\n      `Invalid Option: info must be true, got ${JSON.stringify(options.info)}`,\n    );\n  }\n  // Normalize option `max_record_size`\n  if (\n    options.max_record_size === undefined ||\n    options.max_record_size === null ||\n    options.max_record_size === false\n  ) {\n    options.max_record_size = 0;\n  } else if (\n    Number.isInteger(options.max_record_size) &&\n    options.max_record_size >= 0\n  ) ; else if (\n    typeof options.max_record_size === \"string\" &&\n    /\\d+/.test(options.max_record_size)\n  ) {\n    options.max_record_size = parseInt(options.max_record_size);\n  } else {\n    throw new Error(\n      `Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`,\n    );\n  }\n  // Normalize option `objname`\n  if (\n    options.objname === undefined ||\n    options.objname === null ||\n    options.objname === false\n  ) {\n    options.objname = undefined;\n  } else if (isBuffer(options.objname)) {\n    if (options.objname.length === 0) {\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if (options.encoding === null) ; else {\n      options.objname = options.objname.toString(options.encoding);\n    }\n  } else if (typeof options.objname === \"string\") {\n    if (options.objname.length === 0) {\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  } else if (typeof options.objname === \"number\") ; else {\n    throw new Error(\n      `Invalid Option: objname must be a string or a buffer, got ${options.objname}`,\n    );\n  }\n  if (options.objname !== undefined) {\n    if (typeof options.objname === \"number\") {\n      if (options.columns !== false) {\n        throw Error(\n          \"Invalid Option: objname index cannot be combined with columns or be defined as a field\",\n        );\n      }\n    } else {\n      // A string or a buffer\n      if (options.columns === false) {\n        throw Error(\n          \"Invalid Option: objname field must be combined with columns or be defined as an index\",\n        );\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if (options.on_record === undefined || options.on_record === null) {\n    options.on_record = undefined;\n  } else if (typeof options.on_record !== \"function\") {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_ON_RECORD\",\n      [\n        \"Invalid option `on_record`:\",\n        \"expect a function,\",\n        `got ${JSON.stringify(options.on_record)}`,\n      ],\n      options,\n    );\n  }\n  // Normalize option `on_skip`\n  // options.on_skip ??= (err, chunk) => {\n  //   this.emit('skip', err, chunk);\n  // };\n  if (\n    options.on_skip !== undefined &&\n    options.on_skip !== null &&\n    typeof options.on_skip !== \"function\"\n  ) {\n    throw new Error(\n      `Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`,\n    );\n  }\n  // Normalize option `quote`\n  if (\n    options.quote === null ||\n    options.quote === false ||\n    options.quote === \"\"\n  ) {\n    options.quote = null;\n  } else {\n    if (options.quote === undefined || options.quote === true) {\n      options.quote = Buffer.from('\"', options.encoding);\n    } else if (typeof options.quote === \"string\") {\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if (!isBuffer(options.quote)) {\n      throw new Error(\n        `Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`,\n      );\n    }\n  }\n  // Normalize option `raw`\n  if (\n    options.raw === undefined ||\n    options.raw === null ||\n    options.raw === false\n  ) {\n    options.raw = false;\n  } else if (options.raw !== true) {\n    throw new Error(\n      `Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`,\n    );\n  }\n  // Normalize option `record_delimiter`\n  if (options.record_delimiter === undefined) {\n    options.record_delimiter = [];\n  } else if (\n    typeof options.record_delimiter === \"string\" ||\n    isBuffer(options.record_delimiter)\n  ) {\n    if (options.record_delimiter.length === 0) {\n      throw new CsvError(\n        \"CSV_INVALID_OPTION_RECORD_DELIMITER\",\n        [\n          \"Invalid option `record_delimiter`:\",\n          \"value must be a non empty string or buffer,\",\n          `got ${JSON.stringify(options.record_delimiter)}`,\n        ],\n        options,\n      );\n    }\n    options.record_delimiter = [options.record_delimiter];\n  } else if (!Array.isArray(options.record_delimiter)) {\n    throw new CsvError(\n      \"CSV_INVALID_OPTION_RECORD_DELIMITER\",\n      [\n        \"Invalid option `record_delimiter`:\",\n        \"value must be a string, a buffer or array of string|buffer,\",\n        `got ${JSON.stringify(options.record_delimiter)}`,\n      ],\n      options,\n    );\n  }\n  options.record_delimiter = options.record_delimiter.map(function (rd, i) {\n    if (typeof rd !== \"string\" && !isBuffer(rd)) {\n      throw new CsvError(\n        \"CSV_INVALID_OPTION_RECORD_DELIMITER\",\n        [\n          \"Invalid option `record_delimiter`:\",\n          \"value must be a string, a buffer or array of string|buffer\",\n          `at index ${i},`,\n          `got ${JSON.stringify(rd)}`,\n        ],\n        options,\n      );\n    } else if (rd.length === 0) {\n      throw new CsvError(\n        \"CSV_INVALID_OPTION_RECORD_DELIMITER\",\n        [\n          \"Invalid option `record_delimiter`:\",\n          \"value must be a non empty string or buffer\",\n          `at index ${i},`,\n          `got ${JSON.stringify(rd)}`,\n        ],\n        options,\n      );\n    }\n    if (typeof rd === \"string\") {\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if (typeof options.relax_column_count === \"boolean\") ; else if (\n    options.relax_column_count === undefined ||\n    options.relax_column_count === null\n  ) {\n    options.relax_column_count = false;\n  } else {\n    throw new Error(\n      `Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`,\n    );\n  }\n  if (typeof options.relax_column_count_less === \"boolean\") ; else if (\n    options.relax_column_count_less === undefined ||\n    options.relax_column_count_less === null\n  ) {\n    options.relax_column_count_less = false;\n  } else {\n    throw new Error(\n      `Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`,\n    );\n  }\n  if (typeof options.relax_column_count_more === \"boolean\") ; else if (\n    options.relax_column_count_more === undefined ||\n    options.relax_column_count_more === null\n  ) {\n    options.relax_column_count_more = false;\n  } else {\n    throw new Error(\n      `Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`,\n    );\n  }\n  // Normalize option `relax_quotes`\n  if (typeof options.relax_quotes === \"boolean\") ; else if (\n    options.relax_quotes === undefined ||\n    options.relax_quotes === null\n  ) {\n    options.relax_quotes = false;\n  } else {\n    throw new Error(\n      `Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`,\n    );\n  }\n  // Normalize option `skip_empty_lines`\n  if (typeof options.skip_empty_lines === \"boolean\") ; else if (\n    options.skip_empty_lines === undefined ||\n    options.skip_empty_lines === null\n  ) {\n    options.skip_empty_lines = false;\n  } else {\n    throw new Error(\n      `Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`,\n    );\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if (typeof options.skip_records_with_empty_values === \"boolean\") ; else if (\n    options.skip_records_with_empty_values === undefined ||\n    options.skip_records_with_empty_values === null\n  ) {\n    options.skip_records_with_empty_values = false;\n  } else {\n    throw new Error(\n      `Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`,\n    );\n  }\n  // Normalize option `skip_records_with_error`\n  if (typeof options.skip_records_with_error === \"boolean\") ; else if (\n    options.skip_records_with_error === undefined ||\n    options.skip_records_with_error === null\n  ) {\n    options.skip_records_with_error = false;\n  } else {\n    throw new Error(\n      `Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`,\n    );\n  }\n  // Normalize option `rtrim`\n  if (\n    options.rtrim === undefined ||\n    options.rtrim === null ||\n    options.rtrim === false\n  ) {\n    options.rtrim = false;\n  } else if (options.rtrim !== true) {\n    throw new Error(\n      `Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`,\n    );\n  }\n  // Normalize option `ltrim`\n  if (\n    options.ltrim === undefined ||\n    options.ltrim === null ||\n    options.ltrim === false\n  ) {\n    options.ltrim = false;\n  } else if (options.ltrim !== true) {\n    throw new Error(\n      `Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`,\n    );\n  }\n  // Normalize option `trim`\n  if (\n    options.trim === undefined ||\n    options.trim === null ||\n    options.trim === false\n  ) {\n    options.trim = false;\n  } else if (options.trim !== true) {\n    throw new Error(\n      `Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`,\n    );\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if (options.trim === true && opts.ltrim !== false) {\n    options.ltrim = true;\n  } else if (options.ltrim !== true) {\n    options.ltrim = false;\n  }\n  if (options.trim === true && opts.rtrim !== false) {\n    options.rtrim = true;\n  } else if (options.rtrim !== true) {\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if (options.to === undefined || options.to === null) {\n    options.to = -1;\n  } else {\n    if (typeof options.to === \"string\" && /\\d+/.test(options.to)) {\n      options.to = parseInt(options.to);\n    }\n    if (Number.isInteger(options.to)) {\n      if (options.to <= 0) {\n        throw new Error(\n          `Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`,\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`,\n      );\n    }\n  }\n  // Normalize option `to_line`\n  if (options.to_line === undefined || options.to_line === null) {\n    options.to_line = -1;\n  } else {\n    if (typeof options.to_line === \"string\" && /\\d+/.test(options.to_line)) {\n      options.to_line = parseInt(options.to_line);\n    }\n    if (Number.isInteger(options.to_line)) {\n      if (options.to_line <= 0) {\n        throw new Error(\n          `Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`,\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`,\n      );\n    }\n  }\n  return options;\n};\n\nconst isRecordEmpty = function (record) {\n  return record.every(\n    (field) =>\n      field == null || (field.toString && field.toString().trim() === \"\"),\n  );\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  utf8: Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  utf16le: Buffer.from([255, 254]),\n};\n\nconst transform = function (original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0,\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const { encoding, escape, quote } = this.options;\n      const { quoting, needMoreDataSize, recordDelimiterMaxLength } =\n        this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0\n          ? Buffer.from(\"\\r\\n\", encoding).length\n          : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? quote.length + recordDelimiterMaxLength : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        comment_no_infix,\n        encoding,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line,\n      } = this.options;\n      let { comment, escape, quote, record_delimiter } = this.options;\n      const { bomSkipped, previousBuf, rawBuffer, escapeIsQuote } = this.state;\n      let buf;\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({\n                ...this.original_options,\n                encoding: encoding,\n              });\n              // Options will re-evaluate the Buffer with the new encoding\n              ({ comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(\n            buf,\n            pos,\n          );\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n        if (\n          (chr === cr || chr === nl) &&\n          this.state.wasRowDelimiter === false\n        ) {\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (\n            escape !== null &&\n            this.state.quoting === true &&\n            this.__isEscape(buf, pos, chr) &&\n            pos + escape.length < bufLen\n          ) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n              const isNextChrTrimable =\n                rtrim && this.__isCharTrimable(buf, pos + quote.length);\n              const isNextChrComment =\n                comment !== null &&\n                this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(\n                buf,\n                pos + quote.length,\n                nextChr,\n              );\n              const isNextChrRecordDelimiter =\n                record_delimiter.length === 0\n                  ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length)\n                  : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if (\n                escape !== null &&\n                this.__isEscape(buf, pos, chr) &&\n                this.__isQuote(buf, pos + escape.length)\n              ) {\n                pos += escape.length - 1;\n              } else if (\n                !nextChr ||\n                isNextChrDelimiter ||\n                isNextChrRecordDelimiter ||\n                isNextChrComment ||\n                isNextChrTrimable\n              ) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(\n                  new CsvError(\n                    \"CSV_INVALID_CLOSING_QUOTE\",\n                    [\n                      \"Invalid Closing Quote:\",\n                      `got \"${String.fromCharCode(nextChr)}\"`,\n                      `at line ${this.info.lines}`,\n                      \"instead of delimiter, record delimiter, trimable character\",\n                      \"(if activated) or comment\",\n                    ],\n                    this.options,\n                    this.__infoField(),\n                  ),\n                );\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms)\n                    .map((b) =>\n                      boms[b].equals(this.state.field.toString()) ? b : false,\n                    )\n                    .filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError(\n                      \"INVALID_OPENING_QUOTE\",\n                      [\n                        \"Invalid Opening Quote:\",\n                        `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                        bom ? `(${bom} bom)` : undefined,\n                      ],\n                      this.options,\n                      info,\n                      {\n                        field: this.state.field,\n                      },\n                    ),\n                  );\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(\n              chr,\n              buf,\n              pos,\n            );\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine =\n                this.state.commenting &&\n                this.state.wasQuoting === false &&\n                this.state.record.length === 0 &&\n                this.state.field.length === 0;\n              if (skipCommentLine) {\n                this.info.comment_lines++;\n                // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (\n                  this.state.enabled === false &&\n                  this.info.lines +\n                    (this.state.wasRowDelimiter === true ? 1 : 0) >=\n                    from_line\n                ) {\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if (\n                  skip_empty_lines === true &&\n                  this.state.wasQuoting === false &&\n                  this.state.record.length === 0 &&\n                  this.state.field.length === 0\n                ) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if (errField !== undefined) return errField;\n                this.info.bytes =\n                  this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if (errRecord !== undefined) return errRecord;\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if (this.state.commenting) {\n              continue;\n            }\n            if (\n              comment !== null &&\n              (comment_no_infix === false ||\n                (this.state.record.length === 0 &&\n                  this.state.field.length === 0))\n            ) {\n              const commentCount = this.__compareBytes(comment, buf, pos, chr);\n              if (commentCount !== 0) {\n                this.state.commenting = true;\n                continue;\n              }\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if (this.state.commenting === false) {\n          if (\n            max_record_size !== 0 &&\n            this.state.record_length + this.state.field.length > max_record_size\n          ) {\n            return this.__error(\n              new CsvError(\n                \"CSV_MAX_RECORD_SIZE\",\n                [\n                  \"Max Record Size:\",\n                  \"record exceed the maximum number of tolerated bytes\",\n                  `of ${max_record_size}`,\n                  `at line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n              ),\n            );\n          }\n        }\n        const lappend =\n          ltrim === false ||\n          this.state.quoting === true ||\n          this.state.field.length !== 0 ||\n          !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(\n            new CsvError(\n              \"CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE\",\n              [\n                \"Invalid Closing Quote:\",\n                \"found non trimable byte after quote\",\n                `at line ${this.info.lines}`,\n              ],\n              this.options,\n              this.__infoField(),\n            ),\n          );\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(\n            new CsvError(\n              \"CSV_QUOTE_NOT_CLOSED\",\n              [\n                \"Quote Not Closed:\",\n                `the parsing is finished with an opening quote at line ${this.info.lines}`,\n              ],\n              this.options,\n              this.__infoField(),\n            ),\n          );\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (\n            this.state.wasQuoting === true ||\n            this.state.record.length !== 0 ||\n            this.state.field.length !== 0\n          ) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if (errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values,\n      } = this.options;\n      const { enabled, record } = this.state;\n      if (enabled === false) {\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err =\n          columns === false\n            ? new CsvError(\n                \"CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\",\n                [\n                  \"Invalid Record Length:\",\n                  `expect ${this.state.expectedRecordLength},`,\n                  `got ${recordLength} on line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n                {\n                  record: record,\n                },\n              )\n            : new CsvError(\n                \"CSV_RECORD_INCONSISTENT_COLUMNS\",\n                [\n                  \"Invalid Record Length:\",\n                  `columns length is ${columns.length},`, // rename columns\n                  `got ${recordLength} on line ${this.info.lines}`,\n                ],\n                this.options,\n                this.__infoField(),\n                {\n                  record: record,\n                },\n              );\n        if (\n          relax_column_count === true ||\n          (relax_column_count_less === true &&\n            recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true &&\n            recordLength > this.state.expectedRecordLength)\n        ) {\n          this.info.invalid_field_length++;\n          this.state.error = err;\n          // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n          if (finalErr) return finalErr;\n        }\n      }\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n        return;\n      }\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if (from === 1 || this.info.records >= from) {\n        const { objname } = this.options;\n        // With columns, records are object\n        if (columns !== false) {\n          const obj = {};\n          // Transform record array to an object\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (\n              group_columns_by_name === true &&\n              obj[columns[i].name] !== undefined\n            ) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if (raw === true || info === true) {\n            const extRecord = Object.assign(\n              { record: obj },\n              raw === true\n                ? { raw: this.state.rawBuffer.toString(encoding) }\n                : {},\n              info === true ? { info: this.__infoRecord() } : {},\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          }\n          // Without columns, records are array\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign(\n              { record: record },\n              raw === true\n                ? { raw: this.state.rawBuffer.toString(encoding) }\n                : {},\n              info === true ? { info: this.__infoRecord() } : {},\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record],\n              push,\n            );\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const { firstLineToHeaders } = this.state;\n      try {\n        const headers =\n          firstLineToHeaders === undefined\n            ? record\n            : firstLineToHeaders.call(null, record);\n        if (!Array.isArray(headers)) {\n          return this.__error(\n            new CsvError(\n              \"CSV_INVALID_COLUMN_MAPPING\",\n              [\n                \"Invalid Column Mapping:\",\n                \"expect an array from column function,\",\n                `got ${JSON.stringify(headers)}`,\n              ],\n              this.options,\n              this.__infoField(),\n              {\n                headers: headers,\n              },\n            ),\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const { cast, encoding, rtrim, max_record_size } = this.options;\n      const { enabled, wasQuoting } = this.state;\n      // Short circuit for the from_line options\n      if (enabled === false) {\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n        if (err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if (max_record_size !== 0 && typeof field === \"string\") {\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const { on_record } = this.options;\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const { columns, relax_column_count } = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if (\n        isColumns === true &&\n        relax_column_count &&\n        this.options.columns.length <= this.state.record.length\n      ) {\n        return [undefined, undefined];\n      }\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const { timchars } = this.state;\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const { delimiter, ignore_last_delimiters } = this.options;\n      if (\n        ignore_last_delimiters === true &&\n        this.state.record.length === this.options.columns.length - 1\n      ) {\n        return 0;\n      } else if (\n        ignore_last_delimiters !== false &&\n        typeof ignore_last_delimiters === \"number\" &&\n        this.state.record.length === ignore_last_delimiters - 1\n      ) {\n        return 0;\n      }\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const { record_delimiter } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if (rd[0] !== chr) {\n          continue;\n        }\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const { escape } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const { quote } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from(\"\\r\\n\", encoding),\n        Buffer.from(\"\\n\", encoding),\n        Buffer.from(\"\\r\", encoding),\n      ];\n      loop: for (let i = 0; i < rds.length; i++) {\n        const l = rds[i].length;\n        for (let j = 0; j < l; j++) {\n          if (rds[i][j] !== buf[pos + j]) {\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function (msg) {\n      const { encoding, raw, skip_records_with_error } = this.options;\n      const err = typeof msg === \"string\" ? new Error(msg) : msg;\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(\n            err,\n            raw ? this.state.rawBuffer.toString(encoding) : undefined,\n          );\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return {\n        ...this.info,\n        columns: this.options.columns,\n      };\n    },\n    __infoRecord: function () {\n      const { columns, raw, encoding } = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined,\n      };\n    },\n    __infoField: function () {\n      const { columns } = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column:\n          isColumns === true\n            ? columns.length > this.state.record.length\n              ? columns[this.state.record.length].name\n              : null\n            : this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    },\n  };\n};\n\nconst parse = function (data, opts = {}) {\n  if (typeof data === \"string\") {\n    data = Buffer.from(data);\n  }\n  const records = opts && opts.objname ? {} : [];\n  const parser = transform(opts);\n  const push = (record) => {\n    if (parser.options.objname === undefined) records.push(record);\n    else {\n      records[record[0]] = record[1];\n    }\n  };\n  const close = () => {};\n  const err1 = parser.parse(data, false, push, close);\n  if (err1 !== undefined) throw err1;\n  const err2 = parser.parse(undefined, true, push, close);\n  if (err2 !== undefined) throw err2;\n  return records;\n};\n\nexport { CsvError, parse };\n","var global$1 = (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n  ? global$1.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nkMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  \"[^.[\\\\]]+\" +\n    \"|\" +\n    // Or match property names within brackets.\n    \"\\\\[(?:\" +\n    // Match a non-string expression.\n    \"([^\\\"'][^[]*)\" +\n    \"|\" +\n    // Or match strings (supports escaping characters).\n    \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n    \")\\\\]\" +\n    \"|\" +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n  \"g\",\n);\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  return Object.prototype.toString.call(value);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return (\n    type === \"symbol\" ||\n    (type === \"object\" && value && getTag(value) === \"[object Symbol]\")\n  );\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const type = typeof value;\n  if (\n    type === \"number\" ||\n    type === \"symbol\" ||\n    type === \"boolean\" ||\n    !value ||\n    isSymbol(value)\n  ) {\n    return true;\n  }\n  return (\n    reIsPlainProp.test(value) ||\n    !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n  );\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === \"string\" || isSymbol(value)) return value;\n  const result = `${value}`;\n  // eslint-disable-next-line\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index === length ? object : undefined;\n};\n\nconst is_object = function (obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\n\nconst normalize_columns = function (columns) {\n  if (columns === undefined || columns === null) {\n    return [undefined, undefined];\n  }\n  if (typeof columns !== \"object\") {\n    return [Error('Invalid option \"columns\": expect an array or an object')];\n  }\n  if (!Array.isArray(columns)) {\n    const newcolumns = [];\n    for (const k in columns) {\n      newcolumns.push({\n        key: k,\n        header: columns[k],\n      });\n    }\n    columns = newcolumns;\n  } else {\n    const newcolumns = [];\n    for (const column of columns) {\n      if (typeof column === \"string\") {\n        newcolumns.push({\n          key: column,\n          header: column,\n        });\n      } else if (\n        typeof column === \"object\" &&\n        column !== null &&\n        !Array.isArray(column)\n      ) {\n        if (!column.key) {\n          return [\n            Error('Invalid column definition: property \"key\" is required'),\n          ];\n        }\n        if (column.header === undefined) {\n          column.header = column.key;\n        }\n        newcolumns.push(column);\n      } else {\n        return [\n          Error(\"Invalid column definition: expect a string or an object\"),\n        ];\n      }\n    }\n    columns = newcolumns;\n  }\n  return [undefined, columns];\n};\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(\" \");\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = isBuffer(value)\n          ? value.toString()\n          : value == null\n            ? value\n            : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return \"_\" + match.toLowerCase();\n  });\n};\n\nconst normalize_options = function (opts) {\n  const options = {};\n  // Merge with user options\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `bom`\n  if (\n    options.bom === undefined ||\n    options.bom === null ||\n    options.bom === false\n  ) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    return [\n      new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n        \"option `bom` is optional and must be a boolean value,\",\n        `got ${JSON.stringify(options.bom)}`,\n      ]),\n    ];\n  }\n  // Normalize option `delimiter`\n  if (options.delimiter === undefined || options.delimiter === null) {\n    options.delimiter = \",\";\n  } else if (isBuffer(options.delimiter)) {\n    options.delimiter = options.delimiter.toString();\n  } else if (typeof options.delimiter !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n        \"option `delimiter` must be a buffer or a string,\",\n        `got ${JSON.stringify(options.delimiter)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quote`\n  if (options.quote === undefined || options.quote === null) {\n    options.quote = '\"';\n  } else if (options.quote === true) {\n    options.quote = '\"';\n  } else if (options.quote === false) {\n    options.quote = \"\";\n  } else if (isBuffer(options.quote)) {\n    options.quote = options.quote.toString();\n  } else if (typeof options.quote !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n        \"option `quote` must be a boolean, a buffer or a string,\",\n        `got ${JSON.stringify(options.quote)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `escape_formulas`\n  if (\n    options.escape_formulas === undefined ||\n    options.escape_formulas === null\n  ) {\n    options.escape_formulas = false;\n  } else if (typeof options.escape_formulas !== \"boolean\") {\n    return [\n      new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n        \"option `escape_formulas` must be a boolean,\",\n        `got ${JSON.stringify(options.escape_formulas)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted_empty`\n  if (options.quoted_empty === undefined || options.quoted_empty === null) {\n    options.quoted_empty = undefined;\n  }\n  // Normalize option `quoted_match`\n  if (\n    options.quoted_match === undefined ||\n    options.quoted_match === null ||\n    options.quoted_match === false\n  ) {\n    options.quoted_match = null;\n  } else if (!Array.isArray(options.quoted_match)) {\n    options.quoted_match = [options.quoted_match];\n  }\n  if (options.quoted_match) {\n    for (const quoted_match of options.quoted_match) {\n      const isString = typeof quoted_match === \"string\";\n      const isRegExp = quoted_match instanceof RegExp;\n      if (!isString && !isRegExp) {\n        return [\n          Error(\n            `Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`,\n          ),\n        ];\n      }\n    }\n  }\n  // Normalize option `quoted_string`\n  if (options.quoted_string === undefined || options.quoted_string === null) {\n    options.quoted_string = false;\n  }\n  // Normalize option `eof`\n  if (options.eof === undefined || options.eof === null) {\n    options.eof = true;\n  }\n  // Normalize option `escape`\n  if (options.escape === undefined || options.escape === null) {\n    options.escape = '\"';\n  } else if (isBuffer(options.escape)) {\n    options.escape = options.escape.toString();\n  } else if (typeof options.escape !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`,\n      ),\n    ];\n  }\n  if (options.escape.length > 1) {\n    return [\n      Error(\n        `Invalid Option: escape must be one character, got ${options.escape.length} characters`,\n      ),\n    ];\n  }\n  // Normalize option `header`\n  if (options.header === undefined || options.header === null) {\n    options.header = false;\n  }\n  // Normalize option `columns`\n  const [errColumns, columns] = normalize_columns(options.columns);\n  if (errColumns !== undefined) return [errColumns];\n  options.columns = columns;\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `cast`\n  if (options.cast === undefined || options.cast === null) {\n    options.cast = {};\n  }\n  // Normalize option cast.bigint\n  if (options.cast.bigint === undefined || options.cast.bigint === null) {\n    // Cast boolean to string by default\n    options.cast.bigint = (value) => \"\" + value;\n  }\n  // Normalize option cast.boolean\n  if (options.cast.boolean === undefined || options.cast.boolean === null) {\n    // Cast boolean to string by default\n    options.cast.boolean = (value) => (value ? \"1\" : \"\");\n  }\n  // Normalize option cast.date\n  if (options.cast.date === undefined || options.cast.date === null) {\n    // Cast date to timestamp string by default\n    options.cast.date = (value) => \"\" + value.getTime();\n  }\n  // Normalize option cast.number\n  if (options.cast.number === undefined || options.cast.number === null) {\n    // Cast number to string using native casting by default\n    options.cast.number = (value) => \"\" + value;\n  }\n  // Normalize option cast.object\n  if (options.cast.object === undefined || options.cast.object === null) {\n    // Stringify object as JSON by default\n    options.cast.object = (value) => JSON.stringify(value);\n  }\n  // Normalize option cast.string\n  if (options.cast.string === undefined || options.cast.string === null) {\n    // Leave string untouched\n    options.cast.string = function (value) {\n      return value;\n    };\n  }\n  // Normalize option `on_record`\n  if (\n    options.on_record !== undefined &&\n    typeof options.on_record !== \"function\"\n  ) {\n    return [Error(`Invalid Option: \"on_record\" must be a function.`)];\n  }\n  // Normalize option `record_delimiter`\n  if (\n    options.record_delimiter === undefined ||\n    options.record_delimiter === null\n  ) {\n    options.record_delimiter = \"\\n\";\n  } else if (isBuffer(options.record_delimiter)) {\n    options.record_delimiter = options.record_delimiter.toString();\n  } else if (typeof options.record_delimiter !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`,\n      ),\n    ];\n  }\n  switch (options.record_delimiter) {\n    case \"unix\":\n      options.record_delimiter = \"\\n\";\n      break;\n    case \"mac\":\n      options.record_delimiter = \"\\r\";\n      break;\n    case \"windows\":\n      options.record_delimiter = \"\\r\\n\";\n      break;\n    case \"ascii\":\n      options.record_delimiter = \"\\u001e\";\n      break;\n    case \"unicode\":\n      options.record_delimiter = \"\\u2028\";\n      break;\n  }\n  return [undefined, options];\n};\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nconst stringifier = function (options, state, info) {\n  return {\n    options: options,\n    state: state,\n    info: info,\n    __transform: function (chunk, push) {\n      // Chunk validation\n      if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n        return Error(\n          `Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`,\n        );\n      }\n      // Detect columns from the first record\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (\n            this.options.header === true &&\n            this.options.columns === undefined\n          ) {\n            return Error(\n              \"Undiscoverable Columns: header option requires column option or object records\",\n            );\n          }\n        } else if (this.options.columns === undefined) {\n          const [err, columns] = normalize_columns(Object.keys(chunk));\n          if (err) return;\n          this.options.columns = columns;\n        }\n      }\n      // Emit the header\n      if (this.info.records === 0) {\n        this.bom(push);\n        const err = this.headers(push);\n        if (err) return err;\n      }\n      // Emit and stringify the record if an object or an array\n      try {\n        // this.emit('record', chunk, this.info.records);\n        if (this.options.on_record) {\n          this.options.on_record(chunk, this.info.records);\n        }\n      } catch (err) {\n        return err;\n      }\n      // Convert the record into a string\n      let err, chunk_string;\n      if (this.options.eof) {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      } else {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      }\n      // Emit the csv\n      this.info.records++;\n      push(chunk_string);\n    },\n    stringify: function (chunk, chunkIsHeader = false) {\n      if (typeof chunk !== \"object\") {\n        return [undefined, chunk];\n      }\n      const { columns } = this.options;\n      const record = [];\n      // Record is an array\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        }\n        // Cast record elements\n        for (let i = 0; i < chunk.length; i++) {\n          const field = chunk[i];\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: i,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n        // Record is a literal object\n        // `columns` is always defined: it is either provided or discovered.\n      } else {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n      }\n      let csvrecord = \"\";\n      for (let i = 0; i < record.length; i++) {\n        let options, err;\n\n        let [value, field] = record[i];\n        if (typeof value === \"string\") {\n          options = this.options;\n        } else if (is_object(value)) {\n          options = value;\n          value = options.value;\n          delete options.value;\n          if (\n            typeof value !== \"string\" &&\n            value !== undefined &&\n            value !== null\n          ) {\n            if (err)\n              return [\n                Error(\n                  `Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`,\n                ),\n              ];\n          }\n          options = { ...this.options, ...options };\n          [err, options] = normalize_options(options);\n          if (err !== undefined) {\n            return [err];\n          }\n        } else if (value === undefined || value === null) {\n          options = this.options;\n        } else {\n          return [\n            Error(\n              `Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`,\n            ),\n          ];\n        }\n        const {\n          delimiter,\n          escape,\n          quote,\n          quoted,\n          quoted_empty,\n          quoted_string,\n          quoted_match,\n          record_delimiter,\n          escape_formulas,\n        } = options;\n        if (\"\" === value && \"\" === field) {\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          const shouldQuote =\n            quotedMatch ||\n            true === quoted_empty ||\n            (true === quoted_string && false !== quoted_empty);\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (value) {\n          if (typeof value !== \"string\") {\n            return [\n              Error(\n                `Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`,\n              ),\n            ];\n          }\n          const containsdelimiter =\n            delimiter.length && value.indexOf(delimiter) >= 0;\n          const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          const quotedString = quoted_string && typeof field === \"string\";\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          // See https://github.com/adaltas/node-csv/pull/387\n          // More about CSV injection or formula injection, when websites embed\n          // untrusted input inside CSV files:\n          // https://owasp.org/www-community/attacks/CSV_Injection\n          // http://georgemauer.net/2017/10/07/csv-injection.html\n          // Apple Numbers unicode normalization is empirical from testing\n          if (escape_formulas) {\n            switch (value[0]) {\n              case \"=\":\n              case \"+\":\n              case \"-\":\n              case \"@\":\n              case \"\\t\":\n              case \"\\r\":\n              case \"\\uFF1D\": // Unicode '='\n              case \"\\uFF0B\": // Unicode '+'\n              case \"\\uFF0D\": // Unicode '-'\n              case \"\\uFF20\": // Unicode '@'\n                value = `'${value}`;\n                break;\n            }\n          }\n          const shouldQuote =\n            containsQuote === true ||\n            containsdelimiter ||\n            containsRecordDelimiter ||\n            quoted ||\n            quotedString ||\n            quotedMatch;\n          if (shouldQuote === true && containsEscape === true) {\n            const regexp =\n              escape === \"\\\\\"\n                ? new RegExp(escape + escape, \"g\")\n                : new RegExp(escape, \"g\");\n            value = value.replace(regexp, escape + escape);\n          }\n          if (containsQuote === true) {\n            const regexp = new RegExp(quote, \"g\");\n            value = value.replace(regexp, escape + quote);\n          }\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (\n          quoted_empty === true ||\n          (field === \"\" && quoted_string === true && quoted_empty !== false)\n        ) {\n          csvrecord += quote + quote;\n        }\n        if (i !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      }\n      return [undefined, csvrecord];\n    },\n    bom: function (push) {\n      if (this.options.bom !== true) {\n        return;\n      }\n      push(bom_utf8);\n    },\n    headers: function (push) {\n      if (this.options.header === false) {\n        return;\n      }\n      if (this.options.columns === undefined) {\n        return;\n      }\n      let err;\n      let headers = this.options.columns.map((column) => column.header);\n      if (this.options.eof) {\n        [err, headers] = this.stringify(headers, true);\n        headers += this.options.record_delimiter;\n      } else {\n        [err, headers] = this.stringify(headers);\n      }\n      if (err) return err;\n      push(headers);\n    },\n    __cast: function (value, context) {\n      const type = typeof value;\n      try {\n        if (type === \"string\") {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === \"bigint\") {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === \"number\") {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === \"boolean\") {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === \"object\" && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    },\n  };\n};\n\nconst stringify = function (records, opts = {}) {\n  const data = [];\n  const [err, options] = normalize_options(opts);\n  if (err !== undefined) throw err;\n  const state = {\n    stop: false,\n  };\n  // Information\n  const info = {\n    records: 0,\n  };\n  const api = stringifier(options, state, info);\n  for (const record of records) {\n    const err = api.__transform(record, function (record) {\n      data.push(record);\n    });\n    if (err !== undefined) throw err;\n  }\n  if (data.length === 0) {\n    api.bom((d) => {\n      data.push(d);\n    });\n    const err = api.headers((headers) => {\n      data.push(headers);\n    });\n    if (err !== undefined) throw err;\n  }\n  return data.join(\"\");\n};\n\nexport { stringify };\n","import { parse } from \"csv-parse/browser/esm/sync\";\nimport { stringify } from \"csv-stringify/browser/esm/sync\";\n\nexport function getJSONFromCSV(csv: string, objname?: string) {\n  csv = csv.replace(/^\\uFEFF/, \"\"); // strip BOM markers\n\n  return parse(csv, {\n    columns: true,\n    objname,\n  });\n}\n\nexport function getCSVFromJSON(pathName: string, records: any[]) {\n  return stringify(records, { header: true });\n}\n\nexport function getPaperMailCustomerList(fieldEntriesCSV: string) {\n  function getValueFromInfo(info: any, key: string) {\n    return info[key]?.value ?? \"\";\n  }\n  const fieldEntriesJSON = getJSONFromCSV(fieldEntriesCSV);\n\n  const customers = fieldEntriesJSON.reduce(\n    (acc: any, curr: any) => {\n      const fieldName = curr[\"Field name\"];\n\n      let next = { value: curr[\"Field value\"], date: curr[\"Date\"] };\n      const prev = acc[curr.Email]?.[fieldName];\n      // if prev is more current, keep prev\n      if (prev && prev.date > next.date) {\n        next = prev;\n      }\n\n      return {\n        ...acc,\n        [curr[\"Email\"]]: {\n          ...(acc[curr.Email] ?? {\n            \"First name\": curr[\"First name\"],\n            \"Last name\": curr[\"Last name\"],\n          }),\n          [fieldName]: next,\n        },\n      };\n    },\n    {} as {\n      [email: string]: {\n        [fieldName: string]: { value: string; date: string } | string;\n      };\n    }\n  );\n\n  const customersOptingPaper = Object.entries(customers).reduce(\n    (acc, [email, info]: [string, any]) => {\n      // sometimes, email is ''\n      if (!email) {\n        return acc;\n      }\n      if (getValueFromInfo(info, \"Paper Mail\") !== \"Yes\") {\n        return acc;\n      }\n\n      acc.push({\n        Email: email,\n        \"First name\": info[\"First name\"],\n        \"Last name\": info[\"Last name\"],\n        \"Street Address\": getValueFromInfo(info, \"Street Address\"),\n        City: getValueFromInfo(info, \"City\"),\n        State: getValueFromInfo(info, \"State\"),\n        \"Zip Code\": getValueFromInfo(info, \"Zip Code\"),\n      });\n\n      return acc;\n    },\n    [] as any\n  );\n\n  console.log(JSON.stringify(customersOptingPaper));\n\n  return getCSVFromJSON(\"addresses\", customersOptingPaper);\n}\n","import * as React from \"react\";\nimport { useState } from \"react\";\nimport { getPaperMailCustomerList } from \"./getPaperMailCustomerList\";\n\nexport const GetAddressesForPaperMail = () => {\n  const [downloadLinkSettings, setDownloadLinkSettings] = useState<{\n    show: boolean;\n    href: string | undefined;\n    download: string | undefined;\n  }>({\n    show: false,\n    href: undefined,\n    download: undefined,\n  });\n  const [inputIsDisabled, setInputIsDisabled] = useState(false);\n  const [statusText, setStatusText] = useState(\"\");\n\n  return (\n    <div>\n      <h2>Get Addresses for Paper Mail</h2>\n      <ol>\n        <li>Go to Momence</li>\n        <li>From the sidebar, click into \"Analytics\" &gt; \"Reports\"</li>\n        <li>\n          Scroll and find the section \"Customers.\" Click into \"Custom fields\"\n        </li>\n        <li>Click \"Download summary\" in the top-left corner.</li>\n        <li>Upload the downloaded file here.</li>\n      </ol>\n      <label htmlFor=\"momence-csv\">Upload CSV:</label>\n      <input\n        disabled={inputIsDisabled}\n        type=\"file\"\n        id=\"momence-csv\"\n        name=\"momence-csv\"\n        accept=\".csv\"\n        onChange={(e) => {\n          console.log(\"change\");\n          console.log(\"FILES\", e.target.files);\n          const file = e.target.files?.[0];\n          if (file) {\n            setInputIsDisabled(true);\n            setStatusText(\"Working...\");\n            const reader = new FileReader();\n            reader.readAsText(file);\n            reader.onload = () => {\n              try {\n                if (reader.result) {\n                  if (typeof reader.result !== \"string\") {\n                    throw new Error(\"Reader read file as Array Buffer!\");\n                  }\n                  const csvContent = getPaperMailCustomerList(reader.result);\n                  console.log(csvContent);\n                  const fileName = \"customers-opting-paper.csv\";\n                  const csvFile = new File([csvContent], fileName, {\n                    type: \"text/plain\",\n                  });\n                  setDownloadLinkSettings({\n                    show: true,\n                    href: URL.createObjectURL(csvFile),\n                    download: fileName,\n                  });\n\n                  setStatusText(\"Success!\");\n                }\n              } catch (e) {\n                setStatusText(\"Error: \" + e);\n              }\n            };\n            reader.onerror = () => {\n              console.log(reader.error);\n              setStatusText(\"Error: \" + e);\n            };\n          }\n        }}\n      />\n      <p>{statusText}</p>\n      {downloadLinkSettings.show && (\n        <a\n          href={downloadLinkSettings.href}\n          download={downloadLinkSettings.download}\n        >\n          Download file\n        </a>\n      )}\n    </div>\n  );\n};\n","import * as React from \"react\";\nimport type { HeadFC, PageProps } from \"gatsby\";\nimport \"./index.css\";\nimport { GetAddressesForPaperMail } from \"../components/get-addresses-for-paper-mail\";\n\nconst IndexPage: React.FC<PageProps> = () => {\n  return (\n    <div>\n      <h1>HI Buffalo Tools</h1>\n      <GetAddressesForPaperMail />\n    </div>\n  );\n};\n\nexport default IndexPage;\n\nexport const Head: HeadFC = () => <title>Home Page</title>;\n"],"names":["global$1","global","self","window","lookup","revLookup","Arr","Uint8Array","Array","inited","init","code","i","charCodeAt","encodeChunk","uint8","start","end","tmp","num","output","push","join","fromByteArray","len","length","extraBytes","parts","maxChunkLength","len2","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","value","c","rt","abs","isNaN","floor","log","LN2","toString","isArray","arr","call","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","prototype","arg","encodingOrOffset","this","Error","allocUnsafe","from","TypeError","ArrayBuffer","array","byteOffset","byteLength","undefined","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","slice","fromString","obj","internalIsBuffer","checked","copy","val","type","data","fromObject","assertSize","size","b","_isBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","dir","arrayIndexOf","indexOf","lastIndexOf","indexSize","arrLength","valLength","String","buf","readUInt16BE","foundIndex","found","j","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","poolSize","_augment","Symbol","species","alloc","fill","allocUnsafeSlow","isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","subarray","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","INVALID_BASE64_RE","leadSurrogate","b64","l","placeHolders","L","toByteArray","trim","replace","stringtrim","base64clean","src","dst","isFastBuffer","isSlowBuffer","constructor","CsvError","message","options","contexts","super","captureStackTrace","context","key","JSON","parse","stringify","normalize_columns_array","columns","normalizedColumns","column","disabled","name","ResizeableBuffer","prepend","resize","clone","append","reset","init_state","bomSkipped","bufBytesStart","castField","cast_function","commenting","error","enabled","from_line","escaping","escapeIsQuote","escape","quote","expectedRecordLength","field","firstLineToHeaders","cast_first_line_to_header","needMoreDataSize","comment","delimiter","map","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","record_delimiter","v","trimChars","wasQuoting","wasRowDelimiter","timchars","normalize_options","opts","opt","_","bom","cast","cast_date","date","Date","group_columns_by_name","comment_no_infix","delimiter_json","test","isInteger","ignore_last_delimiters","info","max_record_size","objname","on_record","on_skip","raw","rd","relax_column_count","relax_column_count_less","relax_column_count_more","relax_quotes","skip_empty_lines","skip_records_with_empty_values","skip_records_with_error","rtrim","ltrim","to","to_line","isRecordEmpty","every","boms","utf8","utf16le","records","parser","original_options","comment_lines","empty_lines","invalid_field_length","lines","state","__needMoreData","bufLen","nextBuf","close","bomLength","__autoDiscoverRecordDelimiter","chr","__isEscape","__isQuote","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","err","__error","__infoField","Object","keys","filter","Boolean","recordDelimiterLength","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","delimiterLength","lappend","rappend","recordLength","__firstLineToColumns","finalErr","extRecord","assign","__infoRecord","__push","headers","normalizedHeaders","trimRight","f","__cast","__isFloat","parseFloat","loop1","timchar","isTrim","sourceBuf","targetBuf","targetPos","sourceLength","del","rdLength","rds","loop","msg","__infoDataSet","header","index","isColumns","transform","err1","err2","charCodeOfDot","reEscapeChar","rePropName","RegExp","reIsDeepProp","reIsPlainProp","isSymbol","getTag","castPath","object","isKey","result","expression","subString","stringToPath","toKey","INFINITY","get","path","normalize_columns","newcolumns","k","quoted","escape_formulas","quoted_empty","quoted_match","isRegExp","quoted_string","eof","errColumns","bigint","boolean","getTime","number","bom_utf8","api","__transform","chunk","chunk_string","chunkIsHeader","splice","csvrecord","quotedMatch","containsdelimiter","containsQuote","containsEscape","containsRecordDelimiter","quotedString","shouldQuote","regexp","stringifier","getPaperMailCustomerList","fieldEntriesCSV","getValueFromInfo","_info$key","csv","customers","reduce","acc","curr","fieldName","next","prev","Email","_acc$curr$Email","customersOptingPaper","entries","email","City","State","console","GetAddressesForPaperMail","downloadLinkSettings","setDownloadLinkSettings","useState","show","href","download","inputIsDisabled","setInputIsDisabled","statusText","setStatusText","React","htmlFor","id","accept","onChange","files","file","_e$target$files","reader","FileReader","readAsText","onload","csvContent","fileName","csvFile","File","URL","createObjectURL","onerror","Head"],"sourceRoot":""}